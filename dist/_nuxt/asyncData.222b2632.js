import{m as P,p as k,q as C,s as y,w as A,v as B,u as M}from"./entry.97536b20.js";const z=()=>null;function R(...s){var v,m,_,D,g,w,b,x;const f=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(f);let[t,l,e={}]=s;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(v=e.server)!=null?v:!0,e.default=(m=e.default)!=null?m:z,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(D=(_=e.lazy)!=null?_:e.defer)!=null?D:!1,e.initialCache=(g=e.initialCache)!=null?g:!0;const a=P(),i=B();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;i&&(k(()=>{o.forEach(r=>{r()}),o.splice(0,o.length)}),C(()=>o.splice(0,o.length)))}const d=()=>(a.isHydrating||e.initialCache)&&a.payload.data[t]!==void 0,n={data:y(d()?a.payload.data[t]:(b=(w=e.default)==null?void 0:w.call(e))!=null?b:null),pending:y(!d()),error:y((x=a.payload._errors[t])!=null?x:null)};n.refresh=(o={})=>a._asyncDataPromises[t]?a._asyncDataPromises[t]:o._initial&&d()?a.payload.data[t]:(n.pending.value=!0,a._asyncDataPromises[t]=new Promise((r,u)=>{try{r(l(a))}catch(c){u(c)}}).then(r=>{e.transform&&(r=e.transform(r)),e.pick&&(r=H(r,e.pick)),n.data.value=r,n.error.value=null}).catch(r=>{var u,c;n.error.value=r,n.data.value=M((c=(u=e.default)==null?void 0:u.call(e))!=null?c:null)}).finally(()=>{n.pending.value=!1,a.payload.data[t]=n.data.value,n.error.value&&(a.payload._errors[t]=!0),delete a._asyncDataPromises[t]}),a._asyncDataPromises[t]);const p=()=>n.refresh({_initial:!0}),O=e.server!==!1&&a.payload.serverRendered;{O&&a.isHydrating&&t in a.payload.data?n.pending.value=!1:i&&(a.payload.serverRendered&&a.isHydrating||e.lazy)?i._nuxtOnBeforeMountCbs.push(p):p(),e.watch&&A(e.watch,()=>n.refresh());const o=a.hook("app:data:refresh",r=>{if(!r||r.includes(t))return n.refresh()});i&&C(o)}const h=Promise.resolve(a._asyncDataPromises[t]).then(()=>n);return Object.assign(h,n),h}function j(s){const f=s?Array.isArray(s)?s:[s]:void 0;return P().callHook("app:data:refresh",f)}function H(s,f){const t={};for(const l of f)t[l]=s[l];return t}export{j as r,R as u};
